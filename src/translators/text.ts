import { PromptTemplate } from "@langchain/core/prompts";
import getLLMModel from "../llm.js";

const JSON_TEMPLATE = `
- For the json file format, the translated text do not change the keys and only translate the values. Do not remove $$$$$$$ from the keys.
- For the json file format, the translated text every key is very important, do not miss any key.
- For  the json file format, the translated text should add closing curly brackets to nested object if it is missed. This has been missed multiple times.
- For the json file format, the translated text do not change the case of the keys. Keep the keys in the same case as they are in the text input.
- For the json file format, the translated content is directly sent to JSON.parse() function. Make sure to return only valid JSON data or it will failed to parse.
`

const MDX_TEMPLATE = `
- For the mdx file format, keep the header section keys unchanged and only translate the values. Keys include title, description, image, date, modifiedDate etc
`

const getTranslateTemplate = (fileFormat: string) => {
	console.log("File format:", fileFormat)
	let additionalInstruction = "";
	if (fileFormat === "json") {
		additionalInstruction = JSON_TEMPLATE;
	} else if (fileFormat === "mdx") {
		additionalInstruction = MDX_TEMPLATE;
	}
	return `
Instructions for Translation:
- Translate the following sentence from English to {destLang}
- Keep the file format {fileFormat} same.
- The translated text will be directly written to the file.
- The translated text should not worry about the perfect translation.
${additionalInstruction}
- The translated text should not worry about the perfect translation.
- The translated text should not break the unique words into parts and translate e.g. NextGenAIKit -> Next Gen AI Kit is wrong, it should be NextGenAIKit.
- The translated content will be send to end user without human intervention. You should not include any line which end user can think that this content is generated by the AI e.g. Here is the translation of the given text from English to or similar kind of messages.
- The translated text should not ask for any feedback and should not include any remarks.
- The translated text should not add any Note or Warning: messages to the translation.
- The translated text should not add any introductory or explanatory or warning messages in the response. This will fail further processing.
- The translated text should return only translated message without any additional messages generated by you. It could be Note: or Warning: or general message.
- You should not add any disclaimers or specific types of messages appended to the response.
- The input text is coming as a chunk of text and it will be coming in the same format in the output. Don't add anything apart from the translation to avoid wrong message interpretation.

Original Text Content:
{text}
`;
}

const translate = async (model: any, text: string, destLang: string, fileFormat: string = "text") => {
	try {
		const prompt = PromptTemplate.fromTemplate(getTranslateTemplate(fileFormat));
		// console.log("Prompt:", prompt)

		// console.log("File format:", fileFormat)
		const chain = prompt.pipe(model);
		const response = await chain.invoke({
			destLang,
			text,
			fileFormat,
		}) as string;

		const regex1 = /Here is the translation \w.+/gi; // remove the full like
		const regex2 = /Note: \w.+/gi; // remove the full like
		const regex3 = /Sure, \w.+/gi; // remove the full like
		let regex4 = /^.*Translation: \w.+/;
		return response.replace(regex1, "").replace(regex2, "").replace(regex3, "").replace(regex4, "");

	} catch (e) {
		console.error(e);
		return text;
	}
}


const textTranslator = async (documents: string[], destLang: string, fileFormat?: string, progress?: (percentage: number) => void) => {
	const model = await getLLMModel();
	const texts = [];
	progress?.(0);
	let index = 0;
	for (const document of documents) {
		const content = await translate(model, document, destLang, fileFormat);
		index++;
		progress?.((index / documents.length) * 100);
		// console.log("=====================================")
		// console.log(document)
		// console.log(content)
		// console.log("=====================================")
		texts.push(content);
	}
	return texts?.join("\n\n");
}

function extractAndCorrectJsonFromText(text: string) {
	const lines = text.split('\n');
	let correctedJson = null;

	for (const line of lines) {
		// Simplistic check to find a line that looks like it starts with JSON
		if (line.trim().startsWith('{')) {
			// Attempt to correct and parse the JSON
			try {
				correctedJson = correctJsonStructure(line);
				// Attempt to parse to check validity
				return JSON.parse(correctedJson);
			} catch (error) {
				console.error("Found JSON-like line, but couldn't correct or parse it:", line);
				// Optionally, handle the error or attempt further corrections
			}
		}
	}

	return correctedJson;
}

function correctJsonStructure(jsonString: string) {
	let balance = 0;
	let correctedString = '';

	for (const char of jsonString) {
		correctedString += char;
		if (char === '{') balance++;
		if (char === '}') balance--;
	}

	// If there are more opening braces, add the necessary closing braces
	if (balance > 0) correctedString += '}'.repeat(balance);

	return correctedString;
}



export const jsonTextTranslator = async (documents: string[], destLang: string, fileFormat?: string, progress?: (percentage: number) => void) => {
	const model = await getLLMModel();
	const texts = [];
	const errors = []; // To collect errors for each document
	progress?.(0);
	let index = 0;

	for (const document of documents) {
		let content;
		let attempts = 0;
		const maxAttempts = 3;

		while (attempts < maxAttempts) {
			try {
				content = await translate(model, document, destLang, fileFormat);
				// console.log("=====================================")
				// console.log(document)
				// console.log(content)
				// console.log("=====================================")
				// Try parsing the content right after fetching it
				try {
					const parsedContent = extractAndCorrectJsonFromText(content);
					if (parsedContent === null) {
						throw new Error("No valid JSON object found in the translation");
					}
					texts.push(parsedContent);
					break; // Exit the loop if translation and parsing are successful
				} catch (parseError) {
					// @ts-ignore
					throw new Error(`Parsing error: ${parseError?.message || parseError?.toString()}`);
				}
			} catch (e) {
				console.error(`Document ${index + 1}, Attempt ${attempts + 1} failed:`, e);
				// @ts-ignore
				errors.push({documentIndex: index + 1, attempt: attempts + 1, error: e?.message || e.toString()});
				attempts++;
				if (attempts >= maxAttempts) {
					throw new Error(`Failed to translate document after ${maxAttempts} attempts`);
				}
			}
			if (attempts < maxAttempts) {
				await new Promise(resolve => setTimeout(resolve, 1000)); // Wait before retrying
			}
		}

		index++;
		progress?.((index / documents.length) * 100);
	}

	// return { texts, errors }; // Include errors in the result
	return texts;
	// TODO handle errors as well
};


export default textTranslator;
